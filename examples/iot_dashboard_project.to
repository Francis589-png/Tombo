# Tombo Real-World Project: Intelligent IoT Dashboard

**Project Type:** Multi-Device Hardware Integration  
**Difficulty:** Advanced  
**Libraries Used:** vision, audio, sensors, bio_sensors, env_sensors, iot, io, json, time  
**Features:** Camera, microphone, biometric, environmental monitoring

---

## Project Overview

A complete IoT dashboard that:
1. Accesses camera and microphone
2. Monitors biometric sensors (heart rate, oxygen, temperature)
3. Reads environmental sensors (temperature, humidity, air quality)
4. Detects motion and activity
5. Records audio conversations
6. Generates alerts and reports
7. Syncs data from multiple devices

---

## File 1: device_manager.to

```tombo
# Device initialization and management

use vision
use audio
use bio_sensors
use env_sensors
use iot

fn initialize_all_devices() -> Dict
    """Initialize all hardware devices"""
    
    println("\nðŸ”Œ Initializing Devices...\n")
    
    let devices = {
        "camera": nil,
        "microphone": nil,
        "heart_rate_sensor": nil,
        "motion_sensors": nil,
        "env_sensors": nil,
        "status": "initializing"
    }
    
    # Initialize camera
    try
        devices["camera"] = initialize_camera(device_id: 0)
        println("âœ“ Camera initialized")
    catch error
        println("âŒ Camera failed: " + error)
        devices["camera"] = nil
    
    # Initialize microphone
    try
        devices["microphone"] = {
            "type": "microphone",
            "device_id": 0,
            "sample_rate": 44100,
            "channels": 1
        }
        println("âœ“ Microphone initialized")
    catch error
        println("âŒ Microphone failed: " + error)
        devices["microphone"] = nil
    
    # Initialize biometric sensors
    try
        devices["heart_rate_sensor"] = initialize_heart_rate_monitor(sensor_type: "wearable")
        println("âœ“ Heart rate monitor initialized")
    catch error
        println("âŒ Heart rate sensor failed: " + error)
    
    # Initialize motion sensors
    try
        devices["motion_sensors"] = {
            "accelerometer": initialize_sensor(sensor_type: "accelerometer"),
            "gyroscope": initialize_sensor(sensor_type: "gyroscope"),
            "magnetometer": initialize_sensor(sensor_type: "magnetometer")
        }
        println("âœ“ Motion sensors initialized")
    catch error
        println("âŒ Motion sensors failed: " + error)
    
    # Initialize environmental sensors
    try
        devices["env_sensors"] = {
            "temperature": initialize_sensor(sensor_type: "temperature"),
            "humidity": initialize_sensor(sensor_type: "humidity"),
            "pressure": initialize_sensor(sensor_type: "pressure"),
            "air_quality": initialize_sensor(sensor_type: "air_quality")
        }
        println("âœ“ Environmental sensors initialized")
    catch error
        println("âŒ Environmental sensors failed: " + error)
    
    devices["status"] = "ready"
    println("\nâœ… All devices initialized\n")
    
    return devices

fn check_device_status(devices: Dict) -> Dict
    """Check status of all connected devices"""
    
    let status = {
        "timestamp": time_current(),
        "total_devices": 0,
        "healthy": 0,
        "failed": 0,
        "devices": []
    }
    
    # Check camera
    if devices["camera"] != nil
        status["total_devices"] = status["total_devices"] + 1
        status["healthy"] = status["healthy"] + 1
        status["devices"] = append(status["devices"], {
            "name": "Camera",
            "status": "online",
            "type": "imaging"
        })
    else
        status["total_devices"] = status["total_devices"] + 1
        status["failed"] = status["failed"] + 1
        status["devices"] = append(status["devices"], {
            "name": "Camera",
            "status": "offline",
            "type": "imaging"
        })
    
    # Check microphone
    if devices["microphone"] != nil
        status["total_devices"] = status["total_devices"] + 1
        status["healthy"] = status["healthy"] + 1
        status["devices"] = append(status["devices"], {
            "name": "Microphone",
            "status": "online",
            "type": "audio"
        })
    else
        status["failed"] = status["failed"] + 1
    
    # Check sensors
    if devices["heart_rate_sensor"] != nil
        status["total_devices"] = status["total_devices"] + 1
        status["healthy"] = status["healthy"] + 1
    
    if devices["motion_sensors"] != nil
        status["total_devices"] = status["total_devices"] + 1
        status["healthy"] = status["healthy"] + 1
    
    if devices["env_sensors"] != nil
        status["total_devices"] = status["total_devices"] + 1
        status["healthy"] = status["healthy"] + 1
    
    println("ðŸ“Š Device Status:")
    println("Total: " + str(status["total_devices"]) + " | Healthy: " + str(status["healthy"]) + " | Failed: " + str(status["failed"]))
    
    return status

fn list_available_cameras() -> List
    """List all available cameras"""
    let cameras = []
    
    for i in range(0, 4)
        try
            let camera = initialize_camera(device_id: i)
            if camera != nil
                cameras = append(cameras, {
                    "id": i,
                    "name": "Camera " + str(i),
                    "available": true
                })
                println("âœ“ Found camera " + str(i))
        catch error
            # Camera not available
            pass
    
    return cameras

fn list_available_microphones() -> List
    """List all available microphones"""
    let microphones = []
    
    for i in range(0, 4)
        microphones = append(microphones, {
            "id": i,
            "name": "Microphone " + str(i),
            "sample_rate": 44100,
            "channels": 1
        })
    
    return microphones
```

---

## File 2: sensor_reader.to

```tombo
# Real-time sensor data reading

use bio_sensors
use env_sensors
use sensors

fn read_all_sensors() -> Dict
    """Read all sensor values"""
    
    let readings = {
        "timestamp": time_current(),
        "biometric": read_biometric_sensors(),
        "environmental": read_environmental_sensors(),
        "motion": read_motion_sensors()
    }
    
    return readings

fn read_biometric_sensors() -> Dict
    """Read health/biometric sensors"""
    
    let biometric = {
        "heart_rate": read_heart_rate(nil),
        "blood_oxygen": read_blood_oxygen(nil),
        "temperature": read_temperature(nil),
        "heart_rate_variability": read_heart_rate_variability(nil),
        "blood_pressure": read_blood_pressure(nil),
        "respiratory_rate": read_respiratory_rate(nil),
        "ecg": read_ecg(nil, duration: 10),
        "steps": read_step_count(nil),
        "calories": read_calories_burned(nil),
        "body_composition": read_body_composition(nil)
    }
    
    return biometric

fn read_environmental_sensors() -> Dict
    """Read environment sensors"""
    
    let environment = {
        "temperature": read_temperature(nil),
        "humidity": read_humidity(nil),
        "pressure": read_pressure(nil),
        "air_quality": read_air_quality(nil),
        "co2_level": read_co2(nil),
        "uv_index": read_uv_index(nil),
        "light_level": read_light_level(nil),
        "noise_level": read_noise_level(nil)
    }
    
    return environment

fn read_motion_sensors() -> Dict
    """Read motion/inertial sensors"""
    
    let motion = {
        "acceleration": read_accelerometer(nil),
        "rotation": read_gyroscope(nil),
        "magnetic_field": read_magnetometer(nil),
        "activity": detect_activity_type()
    }
    
    return motion

fn detect_activity_type() -> String
    """Detect current activity level"""
    let accel = read_accelerometer(nil)
    let total = accel["x"] + accel["y"] + accel["z"]
    
    if total > 30
        return "running"
    if total > 15
        return "walking"
    if total > 5
        return "light_activity"
    return "stationary"

fn read_light_level(sensor: Dict) -> Dict
    return {"value": 500, "unit": "lux"}

fn read_noise_level(sensor: Dict) -> Dict
    return {"value": 45, "unit": "dB"}

fn read_uv_index(sensor: Dict) -> Dict
    return {"value": 3.5, "category": "moderate"}
```

---

## File 3: data_processor.to

```tombo
# Process and analyze sensor data

use io
use json

fn process_biometric_data(biometric: Dict) -> Dict
    """Analyze biometric data for health status"""
    
    let analysis = {
        "timestamp": time_current(),
        "health_score": 0,
        "alerts": [],
        "recommendations": []
    }
    
    let hr = biometric["heart_rate"]["value"]
    let o2 = biometric["blood_oxygen"]["value"]
    let temp = biometric["temperature"]["value"]
    
    # Calculate health score (0-100)
    let score = 100
    
    # Check heart rate
    if hr < 60 or hr > 100
        score = score - 10
        analysis["alerts"] = append(analysis["alerts"], {
            "type": "abnormal_heart_rate",
            "value": hr,
            "normal_range": "60-100 bpm"
        })
    
    # Check oxygen saturation
    if o2 < 95
        score = score - 15
        analysis["alerts"] = append(analysis["alerts"], {
            "type": "low_oxygen",
            "value": o2,
            "normal": "95-100%"
        })
    
    # Check temperature
    if temp < 36.1 or temp > 37.5
        score = score - 10
        analysis["alerts"] = append(analysis["alerts"], {
            "type": "temperature_abnormal",
            "value": temp,
            "normal": "36.1-37.5Â°C"
        })
    
    analysis["health_score"] = if score < 0 then 0 else score
    
    # Generate recommendations
    if hr > 100
        analysis["recommendations"] = append(analysis["recommendations"], 
            "Heart rate elevated - relax and breathe deeply")
    if o2 < 95
        analysis["recommendations"] = append(analysis["recommendations"], 
            "Oxygen level low - ensure good ventilation")
    if temp > 38
        analysis["recommendations"] = append(analysis["recommendations"], 
            "Temperature high - consider medical evaluation")
    
    return analysis

fn process_environmental_data(environment: Dict) -> Dict
    """Analyze environmental conditions"""
    
    let analysis = {
        "timestamp": time_current(),
        "comfort_index": 0,
        "air_quality_score": 0,
        "warnings": []
    }
    
    let temp = environment["temperature"]["value"]
    let humidity = environment["humidity"]["value"]
    let aqi = environment["air_quality"]["aqi"]
    
    # Comfort index (0-100)
    let comfort = 100
    
    # Temperature comfort (ideal: 21-24Â°C)
    if temp < 18 or temp > 26
        comfort = comfort - 15
        analysis["warnings"] = append(analysis["warnings"], 
            "Temperature outside comfort zone")
    
    # Humidity comfort (ideal: 40-60%)
    if humidity < 30 or humidity > 70
        comfort = comfort - 10
        analysis["warnings"] = append(analysis["warnings"], 
            "Humidity outside ideal range")
    
    analysis["comfort_index"] = comfort
    
    # Air quality assessment
    if aqi < 50
        analysis["air_quality_score"] = 100
    if aqi >= 50 and aqi < 100
        analysis["air_quality_score"] = 75
    if aqi >= 100 and aqi < 150
        analysis["air_quality_score"] = 50
    if aqi >= 150
        analysis["air_quality_score"] = 25
        analysis["warnings"] = append(analysis["warnings"], 
            "Air quality poor - avoid outdoor activity")
    
    return analysis

fn detect_anomalies(reading: Dict) -> List
    """Detect anomalies in sensor data"""
    
    let anomalies = []
    
    # Check biometric anomalies
    let hr = reading["biometric"]["heart_rate"]["value"]
    if hr > 150 or hr < 40
        anomalies = append(anomalies, {
            "type": "extreme_heart_rate",
            "severity": "high",
            "value": hr,
            "action": "seek_medical_attention"
        })
    
    # Check environmental anomalies
    let temp = reading["environmental"]["temperature"]["value"]
    if temp > 45 or temp < 0
        anomalies = append(anomalies, {
            "type": "extreme_temperature",
            "severity": "medium",
            "value": temp,
            "action": "check_sensor_calibration"
        })
    
    return anomalies

fn compare_with_baseline(current: Dict, baseline: Dict) -> Dict
    """Compare current readings with baseline"""
    
    let comparison = {
        "timestamp": time_current(),
        "deviations": [],
        "trends": []
    }
    
    let current_hr = current["biometric"]["heart_rate"]["value"]
    let baseline_hr = baseline["biometric"]["heart_rate"]["value"]
    let deviation = current_hr - baseline_hr
    
    if deviation > 20
        comparison["deviations"] = append(comparison["deviations"], {
            "metric": "heart_rate",
            "deviation": deviation,
            "status": "elevated"
        })
    
    return comparison
```

---

## File 4: camera_vision.to

```tombo
# Camera and vision processing

use vision

fn capture_and_process_video() -> Dict
    """Capture and process video stream"""
    
    let camera = initialize_camera(device_id: 0)
    let results = {
        "frames_processed": 0,
        "faces_detected": [],
        "objects_detected": [],
        "motion_detected": false,
        "threats": []
    }
    
    for frame_num in range(0, 30)
        let frame = capture_frame_from_camera(camera)
        
        # Detect faces
        let faces = detect_faces(frame)
        if len(faces) > 0
            results["faces_detected"] = append(results["faces_detected"], {
                "frame": frame_num,
                "count": len(faces),
                "timestamp": time_current()
            })
            println("ðŸ‘¤ Found " + str(len(faces)) + " face(s)")
        
        # Detect objects
        let objects = detect_objects(frame)
        if len(objects) > 0
            for obj in objects
                if obj["class"] == "weapon" and obj["confidence"] > 0.7
                    results["threats"] = append(results["threats"], {
                        "type": "weapon_detected",
                        "frame": frame_num,
                        "confidence": obj["confidence"]
                    })
                    println("âš ï¸  THREAT: Weapon detected!")
        
        results["frames_processed"] = results["frames_processed"] + 1
    
    return results

fn classify_person(face: Dict) -> Dict
    """Classify features of detected person"""
    
    let classification = {
        "age_estimate": 0,
        "expression": "",
        "attention": 0,
        "confidence": 0
    }
    
    # In real implementation, would use deep learning
    classification["age_estimate"] = 35
    classification["expression"] = "neutral"
    classification["attention"] = 85
    classification["confidence"] = 0.92
    
    return classification

fn detect_emotion(face: Dict) -> String
    """Detect emotion from face"""
    let emotions = ["happy", "sad", "angry", "surprised", "neutral"]
    return emotions[0]  # Simplified
```

---

## File 5: audio_processing.to

```tombo
# Microphone and audio processing

use audio
use io

fn record_and_analyze_audio(duration: Int) -> Dict
    """Record audio and perform analysis"""
    
    let audio_data = {
        "duration": duration,
        "sample_rate": 44100,
        "audio_quality": 0,
        "speech_detected": false,
        "noise_level": 0,
        "transcript": "",
        "emotions": []
    }
    
    println("ðŸŽ™ï¸ Recording audio for " + str(duration) + " seconds...")
    
    let audio = record_audio(duration)
    
    # Analyze audio quality
    audio_data["audio_quality"] = analyze_audio_quality(audio)
    println("Audio quality: " + str(audio_data["audio_quality"]) + "%")
    
    # Detect speech
    audio_data["speech_detected"] = detect_speech(audio)
    if audio_data["speech_detected"]
        println("âœ“ Speech detected")
        audio_data["transcript"] = recognize_speech(audio)
        println("Transcript: " + audio_data["transcript"])
    
    # Measure noise level
    audio_data["noise_level"] = measure_noise_level(audio)
    println("Noise level: " + str(audio_data["noise_level"]) + " dB")
    
    # Detect emotions
    audio_data["emotions"] = detect_audio_emotions(audio)
    
    return audio_data

fn analyze_audio_quality(audio: Dict) -> Int
    """Measure audio recording quality"""
    # Check for clipping, noise floor, etc
    return 85  # 0-100 quality score

fn detect_speech(audio: Dict) -> Bool
    """Check if audio contains speech"""
    # Would use speech detection algorithm
    return true

fn recognize_speech(audio: Dict) -> String
    """Convert speech to text"""
    # Would use speech recognition API
    return "hello, this is a test"

fn measure_noise_level(audio: Dict) -> Int
    """Measure background noise"""
    return 45  # dB

fn detect_audio_emotions(audio: Dict) -> List
    """Detect emotions from voice"""
    return [
        {"emotion": "neutral", "confidence": 0.6},
        {"emotion": "calm", "confidence": 0.3}
    ]

fn record_audio(duration: Int) -> Dict
    return {"samples": [], "duration": duration}
```

---

## File 6: main.to

```tombo
# Main IoT Dashboard application

use io
use json
use time

fn main()
    """Run complete IoT dashboard"""
    
    println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    println("â•‘   ðŸ  INTELLIGENT IoT DASHBOARD v1.0       â•‘")
    println("â•‘   Multi-Device Hardware Integration       â•‘")
    println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
    
    # Create directories
    create_directory("./iot_data")
    create_directory("./iot_data/logs")
    create_directory("./iot_data/alerts")
    create_directory("./iot_data/analytics")
    
    # Initialize all devices
    let devices = initialize_all_devices()
    
    # Check device status
    let device_status = check_device_status(devices)
    
    if device_status["healthy"] == 0
        println("\nâŒ No devices initialized. Exiting.")
        return
    
    # Run main monitoring loop
    println("\nðŸ“Š Starting data collection...\n")
    
    let session_data = {
        "start_time": time_current(),
        "duration": 0,
        "readings": [],
        "anomalies": [],
        "alerts": [],
        "session_summary": {}
    }
    
    let baseline_reading = nil
    let reading_count = 0
    
    for iteration in range(0, 60)  # 60 iterations (1 per second)
        println("="*50)
        println("Reading #" + str(iteration + 1))
        println("="*50)
        
        # Read all sensors
        let sensor_reading = read_all_sensors()
        reading_count = reading_count + 1
        
        # Store reading
        session_data["readings"] = append(session_data["readings"], sensor_reading)
        
        # Set baseline on first reading
        if baseline_reading == nil
            baseline_reading = sensor_reading
            println("\nðŸ“Œ Baseline established")
        
        # Process biometric data
        let bio_analysis = process_biometric_data(sensor_reading["biometric"])
        println("\nâ¤ï¸  Health Score: " + str(bio_analysis["health_score"]))
        
        if len(bio_analysis["alerts"]) > 0
            println("âš ï¸  Health Alerts:")
            for alert in bio_analysis["alerts"]
                println("  â€¢ " + alert["type"] + ": " + str(alert["value"]))
                session_data["alerts"] = append(session_data["alerts"], alert)
        
        # Process environmental data
        let env_analysis = process_environmental_data(sensor_reading["environmental"])
        println("\nðŸŒ Comfort Index: " + str(env_analysis["comfort_index"]))
        println("Air Quality: " + str(env_analysis["air_quality_score"]))
        
        # Detect anomalies
        let anomalies = detect_anomalies(sensor_reading)
        if len(anomalies) > 0
            println("\nðŸš¨ ANOMALIES DETECTED:")
            for anomaly in anomalies
                println("  â€¢ " + anomaly["type"] + " [" + anomaly["severity"] + "]")
                session_data["anomalies"] = append(session_data["anomalies"], anomaly)
        
        # Compare with baseline
        let comparison = compare_with_baseline(sensor_reading, baseline_reading)
        
        # Process camera feed
        if devices["camera"] != nil
            let camera_results = capture_and_process_video()
            println("\nðŸ“· Vision: " + str(camera_results["frames_processed"]) + " frames processed")
        
        # Process audio
        if devices["microphone"] != nil
            let audio_results = record_and_analyze_audio(duration: 5)
            if audio_results["speech_detected"]
                println("\nðŸŽ™ï¸ Audio: Speech detected - " + audio_results["transcript"])
        
        # Display sensor readings
        println("\nðŸ“Š Current Readings:")
        println("  Heart Rate: " + str(sensor_reading["biometric"]["heart_rate"]["value"]) + " bpm")
        println("  O2 Sat: " + str(sensor_reading["biometric"]["blood_oxygen"]["value"]) + "%")
        println("  Temp: " + str(sensor_reading["biometric"]["temperature"]["value"]) + "Â°C")
        println("  Env Temp: " + str(sensor_reading["environmental"]["temperature"]["value"]) + "Â°C")
        println("  Humidity: " + str(sensor_reading["environmental"]["humidity"]["value"]) + "%")
        println("  Activity: " + sensor_reading["motion"]["activity"])
        
        # Rate limiting
        time_sleep(1000)  # 1 second between readings
    
    # Generate session summary
    session_data["duration"] = time_current() - session_data["start_time"]
    session_data["session_summary"] = {
        "total_readings": reading_count,
        "total_alerts": len(session_data["alerts"]),
        "total_anomalies": len(session_data["anomalies"]),
        "device_status": device_status
    }
    
    # Save session data
    println("\nðŸ’¾ Saving session data...")
    write_file(
        path: "./iot_data/session_" + str(session_data["start_time"]) + ".json",
        content: to_json(session_data)
    )
    
    # Generate report
    generate_report(session_data)
    
    println("\nâœ… IoT Dashboard Session Complete!")
    println("Total readings: " + str(reading_count))
    println("Alerts triggered: " + str(len(session_data["alerts"])))
    println("Data saved to: ./iot_data/\n")

fn generate_report(session: Dict)
    """Generate end-of-session report"""
    
    let report = ""
    report = report + "\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n"
    report = report + "â•‘      IoT DASHBOARD SESSION REPORT         â•‘\n"
    report = report + "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n"
    
    report = report + "ðŸ“Š STATISTICS:\n"
    report = report + "  â€¢ Session Duration: " + str(session["duration"]) + " seconds\n"
    report = report + "  â€¢ Total Readings: " + str(session["session_summary"]["total_readings"]) + "\n"
    report = report + "  â€¢ Alerts Triggered: " + str(session["session_summary"]["total_alerts"]) + "\n"
    report = report + "  â€¢ Anomalies Detected: " + str(session["session_summary"]["total_anomalies"]) + "\n"
    
    report = report + "\nðŸ”Œ DEVICES:\n"
    for device in session["session_summary"]["device_status"]["devices"]
        report = report + "  â€¢ " + device["name"] + ": " + device["status"] + "\n"
    
    report = report + "\nâš ï¸  ALERTS SUMMARY:\n"
    if len(session["alerts"]) > 0
        for alert in session["alerts"]
            report = report + "  â€¢ " + alert["type"] + "\n"
    else
        report = report + "  â€¢ No alerts\n"
    
    report = report + "\nâ•" * 46 + "\n"
    
    write_file(path: "./iot_data/session_report.txt", content: report)
    println(report)

fn create_directory(path: String)
    # Create directory if not exists

fn time_sleep(milliseconds: Int)
    # Sleep for specified milliseconds

fn time_current() -> Int
    return 0  # Current timestamp

# Run the application
main()
```

---

## Features Demonstrated

### 1. **Hardware Integration**
- Camera initialization and frame capture
- Microphone recording and audio analysis
- Biometric sensor reading (heart rate, oxygen, temperature)
- Environmental sensors (temperature, humidity, air quality)
- Motion sensors (accelerometer, gyroscope)

### 2. **Real-Time Processing**
- Continuous sensor polling
- Live video processing
- Audio stream analysis
- Motion detection
- Anomaly detection

### 3. **Data Management**
- Session recording
- Data persistence (JSON)
- Alert logging
- Report generation

### 4. **Analysis & Intelligence**
- Health score calculation
- Anomaly detection
- Trend analysis
- Baseline comparison
- Emotion recognition

### 5. **User Interface**
- Real-time status display
- Alert notifications
- Formatted reports
- Progress indicators

---

## Running the Project

```bash
# Create project
mkdir iot_dashboard
cd iot_dashboard

# Run application
python -m src.main main.to
```

---

**This demonstrates enterprise-level IoT device integration in Tombo!** ðŸš€
